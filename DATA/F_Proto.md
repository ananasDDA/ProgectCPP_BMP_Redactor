# Прототипы функций

Объявление функции предшествует ее определению и указывает имя, тип возвращаемого значения, класс хранения и другие атрибуты функции. Чтобы объявление функции стало ее прототипом, оно должно также задавать типы и идентификаторы аргументов функции.

## Синтаксис
```C++
declaration:
    declaration-specifiersattribute-seqoptinit-declarator-listopt;

/* attribute-seqнеоб. относится только к продуктам Майкрософт */

declaration-specifiers:
    storage-class-specifierdeclaration-specifiers //необ.
    type-specifierdeclaration-specifiers //необ.
    type-qualifierdeclaration-specifiers //необ.

init-declarator-list:
    init-declarator
    init-declarator-list , init-declarator

init-declarator:
    declarator
    declarator = initializer

declarator:
    pointer /*необ*/.direct-declarator

direct-declarator: /* Оператор объявления функции */
    direct-declarator(parameter-type-list) /* Оператор объявления нового стиля */
    direct-declarator(identifier-list opt) /* Оператор объявления старого стиля */
```

Прототип имеет ту же форму, что и определение функции, за исключением того, что он завершается точкой с запятой сразу после закрывающей скобки и, следовательно, не имеет тела. В любом случае возвращаемый тип должен соответствовать возвращаемому типу, указанному в определении функции.

Ниже перечислены важные случаи применения прототипов функций:

* Они определяют тип возвращаемого значения для функции, возвращающих типы, отличные от int. Хотя для функций, возвращающих значения типа int , прототипы не обязательны, рекомендуется их использовать.

* Без полных прототипов выполняются стандартные преобразования, но не производится попытка сравнения типа или количества аргументов с количеством параметров.

* Прототипы используются для инициализации указателей на функции до определения этих функций.

* Список параметров используется для проверки соответствия аргументов в вызове функции и параметров в ее определении.

Преобразованный тип каждого параметра определяет интерпретацию аргументов, помещаемых в стек при вызове функции. Несоответствие типов аргументов и параметров может приводить к неправильной интерпретации аргументов в стеке. Например, если на 16-разрядном компьютере в качестве аргумента передается 16-разрядный указатель, объявленный как параметр `long` , первые 32 бита в стеке интерпретируются как параметр типа `long` . Эта ошибка создает проблемы не только с параметром `long` , но и со всеми последующими параметрами. Ошибки такого типа можно обнаруживать, объявляя полные прототипы для всех функций.

Прототип устанавливает атрибуты функции. После этого вызовы функций, предшествующие определению функции (или в других исходных файлах), можно проверять на несоответствие типов аргументов и возвращаемых типов. Например, если в прототипе указан описатель класса хранения `static` , необходимо также задать класс хранения `static` в определении функции.
Полные объявления параметров (`int a`) могут использоваться совместно с абстрактными деклараторами (`int`) в одном объявлении. Например, следующее объявление является допустимым:

```C
int add( int a, int );
```

Прототип может содержать как тип, так и идентификатор для каждого выражения, которое передается в качестве аргумента. Однако область действия таких идентификаторов распространяется только до конца объявления. Прототип также может отражать тот факт, что число аргументов является переменным, или что никакие аргументы не передаются. Без такого списка выявление несоответствий невозможно, поэтому компилятор не может создавать соответствующие диагностические сообщения. Дополнительные сведения о проверке типов содержатся в статье Аргументы.

Теперь область прототипа в компиляторе Microsoft C соответствует стандарту `ANSI` при компиляции с параметром `/Za` . Если вы объявите в прототипе тег `struct` или union , этот тег добавляется именно в этой области, а не в глобальной области. Например, если выполнять компиляцию с параметром `/Za` в соответствии со стандартом `ANSI`, эту функцию невозможно будет вызвать без получения ошибки несоответствия типов:

```C
void func1( struct S * );
```

Чтобы исправить код, определите или объявите struct или union в глобальной области перед прототипом функции:

```C
struct S;
void func1( struct S * );
```

В `/Z`eразделе тег по-прежнему вводится на глобальном область.


# Определение прототипа
Посмотрим на код:
```cpp
 #include <iostream>
 #include <string>

 int main() {
   std::cout << GetAbsolutePath("main.cpp", "andrey") << std::endl;
 }

 std::string GetAbsolutePath(std::string file_name, std::string user_name) {
   return "home/" + usr_home_dir + "/" + file_name;
 }
```

На первый взгляд программа написана правильно, но при компиляции мы получим ошибку
```
./main.cpp:5:20: error: use of undeclared identifier GetAbsolutePath.
```
Причина, по которой эта программа не компилируется, — компилятор последовательно компилирует содержимое исходных файлов. Когда компилятор достигает вызова функции `GetAbsolutePath` в функции `main`, он не знает, что такое `GetAbsolutePath`, потому что мы определили `GetAbsolutePath` ниже ее вызова.

Теперь посмотрим на такой пример:
```cpp
 #include <iostream>
 #include <string>

 // прототип
 std::string GetAbsolutePath(std::string, std::string);

 int main() {
   std::cout << GetAbsolutePath("main.cpp", "andrey") << std::endl;
 }

 // определение
 std::string GetAbsolutePath(std::string file_name, std::string user_name) {
   return "home/" + usr_home_dir + "/" + file_name;
 }
 ```
 Здесь мы определили прототип функции в верхней части. Теперь программа скомпилируется и будет работать.

Синтаксис прототипов довольно простой и похож на синтаксис определения функций: <ТИП ВОЗВРАЩАЕМОГО ЗНАЧЕНИЯ> <ИМЯ> <КОЛИЧЕСТВО И ТИП АРГУМЕНТОВ>. Поскольку прототип функции является оператором, он должен завершаться точкой с запятой.

Прототип функции не требует предоставления имен переменных-параметров, достаточно списка типов.

## Зачем нужны прототипы.

Прототип описывает интерфейс функции для компилятора. Это значит, что он сообщает компилятору, каков тип возвращаемого значения, а также количество и тип аргументов функции.

В нашем случае прототип сообщает компилятору, что функция GetAbsolutePath возвращает значение типа std::string и принимает два аргумента такого же типа. Если программа не предоставит эти аргументы, то прототип позволит компилятору перехватить такую ошибку.

Прототипирование функций позволяет разбивать программу на множество модулей, которые компилируются независимо друг от друга и потом собираются вместе. В этом случае компилятор может вообще не иметь доступа к коду функции во время компиляции main(). То же самое справедливо и в ситуации, когда функция является частью библиотеки.

Прототипы значительно снижают вероятность допущения ошибок. Например, в языке С нет прототипов, и если функция ожидает тип int, а мы передадим в нее double, то могут возникать странные ошибки — потеря точности числа. В C++ же это удастся отловить на этапе компиляции.
